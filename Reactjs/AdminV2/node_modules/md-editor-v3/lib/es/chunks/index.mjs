import { inject, watch, toRef, onMounted, nextTick, shallowRef, ref, computed, defineComponent, createVNode, Fragment, reactive, provide, onBeforeUnmount } from "vue";
import { e as configOption, p as prefix, m as mermaidUrl, k as katexUrl, f as codeCss, h as highlightUrl, s as staticTextDefault, a as iconfontSvgUrl, i as iconfontClassUrl, g as prettierUrl, j as cropperUrl, b as allToolbar, d as allFooter } from "./config.mjs";
import { a as generateCodeRowNumber, b as bus, P as PUSH_CATALOG, C as CATALOG_CHANGED, R as RERENDER, B as BUILD_FINISHED, O as ON_SAVE, E as ERROR_CATCHER, U as UPLOAD_IMAGE, c as CHANGE_CATALOG_VISIBLE, d as PAGE_FULL_SCREEN_CHANGED, F as FULL_SCREEN_CHANGED, e as PREVIEW_CHANGED, f as PREVIEW_ONLY_CHANGED, H as HTML_PREVIEW_CHANGED, h as CATALOG_VISIBLE_CHANGED, i as REPLACE, j as CHANGE_FULL_SCREEN, k as EVENT_LISTENER, l as getNextId } from "./index4.mjs";
import { a as appendHandler, u as updateHandler } from "./dom.mjs";
import { debounce, uuid, deepMerge, deepClone } from "@vavt/util";
import mediumZoom from "medium-zoom";
import copy from "copy-to-clipboard";
import mdit from "markdown-it";
import ImageFiguresPlugin from "markdown-it-image-figures";
import TaskListPlugin from "markdown-it-task-lists";
import XSSPlugin from "markdown-it-xss";
import { LRUCache } from "lru-cache";
const userZoom = (props, html) => {
  const editorId = inject("editorId");
  const { noImgZoomIn } = props;
  let zoomHander = () => {
  };
  watch(
    [html, toRef(props.setting, "preview")],
    () => {
      if (!noImgZoomIn && props.setting.preview) {
        zoomHander();
      }
    },
    {
      immediate: true
    }
  );
  onMounted(() => {
    zoomHander = debounce(() => {
      const imgs = document.querySelectorAll(`#${editorId}-preview img`);
      if (imgs.length === 0) {
        return;
      }
      mediumZoom(imgs, {
        background: "#00000073"
      });
    });
  });
};
const StrIcon = (name, customIcon) => {
  if (typeof customIcon[name] === "string") {
    return customIcon[name];
  }
  const defaultStr = `<i class="${prefix}-iconfont ${prefix}-icon-${name}"></i>`;
  switch (configOption.iconfontType) {
    case "svg": {
      return `<svg class="${prefix}-icon" aria-hidden="true"><use xlink:href="#${prefix}-icon-${name}"></use></svg>`;
    }
    default: {
      return defaultStr;
    }
  }
};
const useCopyCode = (props, html, key) => {
  const editorId = inject("editorId");
  const ult = inject("usedLanguageText");
  const customIcon = inject("customIcon");
  const initCopyEntry = () => {
    document.querySelectorAll(`#${editorId}-preview pre`).forEach((pre) => {
      var _a, _b;
      let clearTimer = -1;
      (_a = pre.querySelector(".copy-button")) == null ? void 0 : _a.remove();
      const copyBtnText = ((_b = ult.value.copyCode) == null ? void 0 : _b.text) || "复制代码";
      const copyButton = document.createElement("span");
      copyButton.setAttribute("class", "copy-button");
      copyButton.dataset.tips = copyBtnText;
      copyButton.innerHTML = StrIcon("copy", customIcon.value);
      copyButton.addEventListener("click", () => {
        var _a2, _b2;
        clearTimeout(clearTimer);
        const codeText = pre.querySelector("code").innerText;
        const success = copy(props.formatCopiedText(codeText));
        const succssTip = ((_a2 = ult.value.copyCode) == null ? void 0 : _a2.successTips) || "已复制！";
        const failTip = ((_b2 = ult.value.copyCode) == null ? void 0 : _b2.failTips) || "已复制！";
        copyButton.dataset.tips = success ? succssTip : failTip;
        clearTimer = window.setTimeout(() => {
          copyButton.dataset.tips = copyBtnText;
        }, 1500);
      });
      pre.appendChild(copyButton);
    });
  };
  const htmlChanged = () => {
    nextTick(initCopyEntry);
  };
  const settingPreviewChanged = (nVal) => {
    if (nVal) {
      nextTick(initCopyEntry);
    }
  };
  watch([html, key], htmlChanged);
  watch(() => props.setting.preview, settingPreviewChanged);
  watch(() => props.setting.htmlPreview, settingPreviewChanged);
  watch(() => ult.value, initCopyEntry);
  onMounted(initCopyEntry);
};
const useHighlight = (props) => {
  var _a;
  const hljsConf = (_a = configOption.editorExtensions) == null ? void 0 : _a.highlight;
  const hljs = hljsConf == null ? void 0 : hljsConf.instance;
  const highlightUrl2 = inject("highlight");
  const hljsRef = shallowRef(hljs);
  onMounted(() => {
    if (props.noHighlight) {
      return;
    }
    if (!hljsRef.value) {
      const highlightScript = document.createElement("script");
      highlightScript.src = highlightUrl2.value.js;
      highlightScript.onload = () => {
        hljsRef.value = window.hljs;
      };
      highlightScript.id = `${prefix}-hljs`;
      appendHandler(highlightScript, "hljs");
      const highlightLink = document.createElement("link");
      highlightLink.rel = "stylesheet";
      highlightLink.href = highlightUrl2.value.css;
      highlightLink.id = `${prefix}-hlCss`;
      appendHandler(highlightLink);
    }
  });
  watch(
    () => highlightUrl2.value.css,
    (url) => {
      updateHandler(`${prefix}-hlCss`, "href", url);
    }
  );
  return hljsRef;
};
const useMermaid = (props) => {
  const theme = inject("theme");
  const { editorExtensions, mermaidConfig } = configOption;
  const mermaidConf = editorExtensions == null ? void 0 : editorExtensions.mermaid;
  const mermaidRef = shallowRef(mermaidConf == null ? void 0 : mermaidConf.instance);
  const reRenderRef = shallowRef(-1);
  const mermaidCache = new LRUCache({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  });
  const configMermaid = () => {
    const mermaid = mermaidRef.value;
    if (!props.noMermaid && mermaid) {
      mermaid.initialize(
        mermaidConfig({
          startOnLoad: false,
          theme: theme.value === "dark" ? "dark" : "default"
        })
      );
      reRenderRef.value = reRenderRef.value + 1;
    }
  };
  watch(
    () => theme.value,
    () => {
      mermaidCache.clear();
      configMermaid();
    }
  );
  onMounted(() => {
    if (props.noMermaid) {
      return;
    }
    if (!(mermaidConf == null ? void 0 : mermaidConf.instance)) {
      const jsSrc = (mermaidConf == null ? void 0 : mermaidConf.js) || mermaidUrl;
      if (/\.mjs/.test(jsSrc)) {
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          jsSrc
        ).then((module) => {
          mermaidRef.value = module.default;
          configMermaid();
        });
      } else {
        const mermaidScript = document.createElement("script");
        mermaidScript.id = `${prefix}-mermaid`;
        mermaidScript.src = jsSrc;
        mermaidScript.onload = () => {
          mermaidRef.value = window.mermaid;
          configMermaid();
        };
        appendHandler(mermaidScript, "mermaid");
      }
    }
  });
  const replaceMermaid = () => {
    nextTick(() => {
      if (!props.noMermaid && mermaidRef.value) {
        const mermaidSourceEles = document.querySelectorAll(
          `div.${prefix}-mermaid`
        );
        const svgContainingElement = document.createElement("div");
        svgContainingElement.style.width = document.body.offsetWidth + "px";
        svgContainingElement.style.height = document.body.offsetHeight + "px";
        svgContainingElement.style.position = "fixed";
        svgContainingElement.style.zIndex = "-10000";
        svgContainingElement.style.top = "-10000";
        let count = mermaidSourceEles.length;
        if (count > 0) {
          document.body.appendChild(svgContainingElement);
        }
        mermaidSourceEles.forEach(async (item) => {
          let mermaidHtml = mermaidCache.get(item.innerText);
          if (!mermaidHtml) {
            const idRand = uuid();
            const render = mermaidRef.value.renderAsync || mermaidRef.value.render;
            let svg = "";
            try {
              svg = await render(idRand, item.innerText, svgContainingElement);
            } catch (error) {
            }
            mermaidHtml = await props.sanitizeMermaid(
              typeof svg === "string" ? svg : svg.svg
            );
            mermaidCache.set(item.innerText, mermaidHtml);
          }
          const p = document.createElement("p");
          p.className = `${prefix}-mermaid`;
          p.setAttribute("data-processed", "");
          p.innerHTML = mermaidHtml;
          if (item.dataset.line !== void 0) {
            p.dataset.line = item.dataset.line;
          }
          item.replaceWith(p);
          if (--count === 0) {
            svgContainingElement.remove();
          }
        });
      }
    });
  };
  return { mermaidRef, reRenderRef, replaceMermaid };
};
const useKatex = (props) => {
  var _a;
  const katexConf = (_a = configOption.editorExtensions) == null ? void 0 : _a.katex;
  const katexIns = katexConf == null ? void 0 : katexConf.instance;
  const katex = shallowRef(katexIns);
  onMounted(() => {
    if (!props.noKatex && !katex.value) {
      const katexScript = document.createElement("script");
      katexScript.src = (katexConf == null ? void 0 : katexConf.js) || katexUrl.js;
      katexScript.onload = () => {
        katex.value = window.katex;
      };
      katexScript.id = `${prefix}-katex`;
      const katexLink = document.createElement("link");
      katexLink.rel = "stylesheet";
      katexLink.href = (katexConf == null ? void 0 : katexConf.css) || katexUrl.css;
      katexLink.id = `${prefix}-katexCss`;
      appendHandler(katexScript, "katex");
      appendHandler(katexLink);
    }
  });
  return katex;
};
const MermaidPlugin = (md, options) => {
  const temp = md.renderer.rules.fence.bind(md.renderer.rules);
  md.renderer.rules.fence = (tokens, idx, ops, env, slf) => {
    const token = tokens[idx];
    const code = token.content.trim();
    if (token.info === "mermaid") {
      let line;
      if (tokens[idx].map && tokens[idx].level === 0) {
        line = tokens[idx].map[0];
        tokens[idx].attrSet("data-line", String(line));
      }
      return `<div class="${prefix}-mermaid" ${line !== void 0 ? "data-line=" + line : ""} data-mermaid-theme=${options.themeRef.value}>${code}</div>`;
    }
    return temp(tokens, idx, ops, env, slf);
  };
};
const MermaidPlugin$1 = MermaidPlugin;
const isValidDelim = (state, pos) => {
  let can_open = true, can_close = true;
  const max = state.posMax;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) {
    can_close = false;
  }
  if (nextChar === 32 || nextChar === 9) {
    can_open = false;
  }
  return {
    can_open,
    can_close
  };
};
const math_inline = (state, silent) => {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$") {
    return false;
  }
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\") {
      pos -= 1;
    }
    if ((match - pos) % 2 == 1) {
      break;
    }
    match += 1;
  }
  if (match === -1) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
};
const math_block = (state, start, end, silent) => {
  let firstLine, lastLine, next, lastPos, found = false, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start];
  if (pos + 2 > max) {
    return false;
  }
  if (state.src.slice(pos, pos + 2) !== "$$") {
    return false;
  }
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent) {
    return true;
  }
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end) {
      break;
    }
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
};
const KatexPlugin = (md, options) => {
  const katexInline = (str) => {
    if (options.katexRef.value) {
      const html = options.katexRef.value.renderToString(str, {
        throwOnError: false
      });
      return `<span class="${prefix}-katex-inline" data-processed>${html}</span>`;
    } else {
      return `<span class="${prefix}-katex-inline">${str}</span>`;
    }
  };
  const katexBlock = (str, lineNum) => {
    if (options.katexRef.value) {
      const html = options.katexRef.value.renderToString(str, {
        throwOnError: false,
        displayMode: true
      });
      return `<p class="${prefix}-katex-block" data-line=${lineNum} data-processed>${html}</p>`;
    } else {
      return `<p class="${prefix}-katex-block" data-line=${lineNum}>${str}</p>`;
    }
  };
  md.inline.ruler.after("escape", "math_inline", math_inline);
  md.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md.renderer.rules.math_inline = (tokens, idx) => {
    return katexInline(tokens[idx].content);
  };
  md.renderer.rules.math_block = (tokens, idx) => {
    return katexBlock(tokens[idx].content, tokens[idx].map[0]) + "\n";
  };
};
const KatexPlugin$1 = KatexPlugin;
const AdmonitionPlugin = (md, options) => {
  options = options || {};
  const markers = 3, markerStr = options.marker || "!", markerChar = markerStr.charCodeAt(0), markerLen = markerStr.length;
  let type = "", title = "";
  const render = (tokens, idx, _options, _env, self) => {
    const token = tokens[idx];
    if (token.type === "admonition_open") {
      tokens[idx].attrPush([
        "class",
        `${prefix}-admonition ${prefix}-admonition-${token.info}`
      ]);
      tokens[idx].attrSet("data-line", String(tokens[idx].map[0]));
    } else if (token.type === "admonition_title_open") {
      tokens[idx].attrPush(["class", `${prefix}-admonition-title`]);
    }
    return self.renderToken(tokens, idx, _options);
  };
  const validate = (params) => {
    const array = params.trim().split(" ", 2);
    title = "";
    type = array[0];
    if (array.length > 1) {
      title = params.substring(type.length + 2);
    }
    if (title === "" || !title) {
      title = type;
    }
  };
  md.block.ruler.before(
    "code",
    "admonition",
    (state, startLine, endLine, silent) => {
      let pos, nextLine, token, autoClosed = false, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (markerChar !== state.src.charCodeAt(start)) {
        return false;
      }
      for (pos = start + 1; pos <= max; pos++) {
        if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
          break;
        }
      }
      const markerCount = Math.floor((pos - start) / markerLen);
      if (markerCount !== markers) {
        return false;
      }
      pos -= (pos - start) % markerLen;
      const markup = state.src.slice(start, pos);
      const params = state.src.slice(pos, max);
      validate(params);
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (start < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (markerChar !== state.src.charCodeAt(start)) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        for (pos = start + 1; pos <= max; pos++) {
          if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
            break;
          }
        }
        if (Math.floor((pos - start) / markerLen) < markerCount) {
          continue;
        }
        pos -= (pos - start) % markerLen;
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        autoClosed = true;
        break;
      }
      const oldParent = state.parentType;
      const oldLineMax = state.lineMax;
      state.parentType = "root";
      state.lineMax = nextLine;
      token = state.push("admonition_open", "div", 1);
      token.markup = markup;
      token.block = true;
      token.info = type;
      token.map = [startLine, nextLine];
      token = state.push("admonition_title_open", "p", 1);
      token.markup = markup + " " + type;
      token.map = [startLine, nextLine];
      token = state.push("inline", "", 0);
      token.content = title;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("admonition_title_close", "p", -1);
      token.markup = markup + " " + type;
      state.md.block.tokenize(state, startLine + 1, nextLine);
      token = state.push("admonition_close", "div", -1);
      token.markup = state.src.slice(start, pos);
      token.block = true;
      state.parentType = oldParent;
      state.lineMax = oldLineMax;
      state.line = nextLine + (autoClosed ? 1 : 0);
      return true;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  );
  md.renderer.rules["admonition_open"] = render;
  md.renderer.rules["admonition_title_open"] = render;
  md.renderer.rules["admonition_title_close"] = render;
  md.renderer.rules["admonition_close"] = render;
};
const AdmonitionPlugin$1 = AdmonitionPlugin;
const HeadingPlugin = (md, options) => {
  md.renderer.rules.heading_open = (tokens, idx) => {
    var _a;
    const token = tokens[idx];
    const text = ((_a = tokens[idx + 1].children) == null ? void 0 : _a.reduce((p, c) => {
      return p + (c.content || "");
    }, "")) || "";
    const level = token.markup.length;
    options.headsRef.value.push({
      text,
      level
    });
    if (token.map && token.level === 0) {
      token.attrSet("data-line", String(token.map[0]));
      token.attrSet(
        "id",
        options.mdHeadingId(text, level, options.headsRef.value.length)
      );
    }
    return md.renderer.renderToken(tokens, idx, options);
  };
  md.renderer.rules.heading_close = (tokens, idx, opts, _env, self) => {
    return self.renderToken(tokens, idx, opts);
  };
};
const HeadingPlugin$1 = HeadingPlugin;
const codetabs = (md, _opts) => {
  const defaultRender = md.renderer.rules.fence, unescapeAll = md.utils.unescapeAll, re = /\[(\w*)(?::([\w ]*))?\]/;
  function getInfo(token) {
    return token.info ? unescapeAll(token.info).trim() : "";
  }
  function getGroupAndTab(token) {
    const info = getInfo(token), [group = null, tab = ""] = (re.exec(info) || []).slice(1);
    return [group, tab];
  }
  function getLangName(token) {
    const info = getInfo(token);
    return info ? info.split(/(\s+)/g)[0] : "";
  }
  const fenceGroup = (tokens, idx, options, env, slf) => {
    if (tokens[idx].hidden) {
      return "";
    }
    const [GROUP, _] = getGroupAndTab(tokens[idx]);
    if (GROUP === null) {
      return defaultRender(tokens, idx, options, env, slf);
    }
    let token, group, tab, checked, labels = "", pres = "";
    for (let i = idx; i < tokens.length; i++) {
      token = tokens[i];
      [group, tab] = getGroupAndTab(token);
      if (group !== GROUP) {
        break;
      }
      token.info = token.info.replace(re, "");
      token.hidden = true;
      checked = i - idx > 0 ? "" : " checked";
      labels += `<li><input type="radio" name="label-group-${_opts.editorId}-${idx}"${checked}><label for="group-${_opts.editorId}-${idx}-tab-${i - idx}" onclick="this.previousElementSibling.click()">${tab || getLangName(token)}</label></li>
`;
      pres += `<input type="radio" id="group-${_opts.editorId}-${idx}-tab-${i - idx}" name="group-${_opts.editorId}-${idx}"${checked}>
` + defaultRender(tokens, i, options, env, slf);
    }
    return '<div class="code-tabs">\n<ul>\n' + labels + "</ul>\n" + pres + "</div>";
  };
  md.renderer.rules.fence = fenceGroup;
};
const CodeTabsPlugin = codetabs;
const initLineNumber = (md) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((rule) => {
    const backup = md.renderer.rules[rule];
    if (!backup) {
      md.renderer.rules[rule] = (tokens, idx, options, _env, self) => {
        let line;
        if (tokens[idx].map && tokens[idx].level === 0) {
          line = tokens[idx].map[0];
          tokens[idx].attrSet("data-line", String(line));
        }
        return self.renderToken(tokens, idx, options);
      };
    } else {
      md.renderer.rules[rule] = (tokens, idx, options, env, self) => {
        let line;
        const _htmlCode = backup(tokens, idx, options, env, self);
        if (tokens[idx].map && tokens[idx].level === 0 && !/^<!--/.test(_htmlCode)) {
          line = tokens[idx].map[0];
          return _htmlCode.replace(/^(<[^>]*)/, `$1 data-line="${line}"`);
        }
        return _htmlCode;
      };
    }
  });
};
const useMarkdownIt = (props, previewOnly) => {
  const { editorConfig, markdownItConfig, markdownItPlugins } = configOption;
  const editorId = inject("editorId");
  const showCodeRowNumber = inject("showCodeRowNumber");
  const themeRef = inject("theme");
  const headsRef = ref([]);
  const hljsRef = useHighlight(props);
  const katexRef = useKatex(props);
  const { reRenderRef, replaceMermaid } = useMermaid(props);
  const md = mdit({
    html: true,
    breaks: true
  });
  markdownItConfig(md, {
    editorId
  });
  const plugins = [
    {
      type: "katex",
      plugin: KatexPlugin$1,
      options: { katexRef }
    },
    {
      type: "image",
      plugin: ImageFiguresPlugin,
      options: { figcaption: true, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: AdmonitionPlugin$1,
      options: {}
    },
    {
      type: "taskList",
      plugin: TaskListPlugin,
      options: {}
    },
    {
      type: "heading",
      plugin: HeadingPlugin$1,
      options: { mdHeadingId: props.mdHeadingId, headsRef }
    },
    {
      type: "codeTabs",
      plugin: CodeTabsPlugin,
      options: { editorId }
    },
    {
      type: "xss",
      plugin: XSSPlugin,
      options: {
        // https://github.com/leizongmin/js-xss/blob/master/README.zh.md
        xss(xss) {
          return {
            whiteList: Object.assign({}, xss.getDefaultWhiteList(), {
              // 支持任务列表
              input: ["class", "disabled", "type", "checked"],
              // 主要支持youtobe、腾讯视频、哔哩哔哩等内嵌视频代码
              iframe: [
                "class",
                "width",
                "height",
                "src",
                "title",
                "border",
                "frameborder",
                "framespacing",
                "allow",
                "allowfullscreen"
              ]
            })
          };
        }
      }
    }
  ];
  if (!props.noMermaid) {
    plugins.push({
      type: "mermaid",
      plugin: MermaidPlugin$1,
      options: { themeRef }
    });
  }
  markdownItPlugins(plugins, {
    editorId
  }).forEach((item) => {
    md.use(item.plugin, item.options);
  });
  const userDefHighlight = md.options.highlight;
  md.set({
    highlight: (str, language, attrs) => {
      if (userDefHighlight) {
        const result = userDefHighlight(str, language, attrs);
        if (result) {
          return result;
        }
      }
      let codeHtml;
      if (!props.noHighlight && hljsRef.value) {
        const hljsLang = hljsRef.value.getLanguage(language);
        if (hljsLang) {
          codeHtml = hljsRef.value.highlight(str, {
            language,
            ignoreIllegals: true
          }).value;
        } else {
          codeHtml = hljsRef.value.highlightAuto(str).value;
        }
      } else {
        codeHtml = md.utils.escapeHtml(str);
      }
      const codeSpan = showCodeRowNumber ? generateCodeRowNumber(codeHtml.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${codeHtml.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${language}" language=${language}>${codeSpan}</code></pre>`;
    }
  });
  initLineNumber(md);
  const key = ref(`_article-key_${uuid()}`);
  const html = ref(props.sanitize(md.render(props.modelValue)));
  const updatedTodo = () => {
    bus.emit(editorId, BUILD_FINISHED, html.value);
    props.onHtmlChanged(html.value);
    props.onGetCatalog(headsRef.value);
    bus.emit(editorId, CATALOG_CHANGED, headsRef.value);
    replaceMermaid();
  };
  onMounted(updatedTodo);
  const markHtml = () => {
    headsRef.value = [];
    html.value = props.sanitize(md.render(props.modelValue));
    updatedTodo();
  };
  const needReRender = computed(() => {
    return (props.noKatex || katexRef.value) && (props.noHighlight || hljsRef.value);
  });
  watch(
    [toRef(props, "modelValue"), needReRender, reRenderRef],
    debounce(
      markHtml,
      (editorConfig == null ? void 0 : editorConfig.renderDelay) !== void 0 ? editorConfig == null ? void 0 : editorConfig.renderDelay : previewOnly ? 0 : 500
    )
  );
  onMounted(() => {
    bus.on(editorId, {
      name: PUSH_CATALOG,
      callback() {
        bus.emit(editorId, CATALOG_CHANGED, headsRef.value);
      }
    });
    bus.on(editorId, {
      name: RERENDER,
      callback: () => {
        markHtml();
        key.value = `_article-key_${uuid()}`;
      }
    });
  });
  return { html, key };
};
const useMarkdownIt$1 = useMarkdownIt;
const contentPreviewProps = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({ preview: true })
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: false
  },
  sanitize: {
    type: Function,
    default: (html) => html
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: false
  },
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  previewOnly: {
    type: Boolean,
    default: false
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  }
};
const contentProps = {
  ...contentPreviewProps,
  updateModelValue: {
    type: Function,
    default: () => {
    }
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: "light"
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWitdh: {
    type: String
  },
  onInputBoxWitdhChange: {
    type: Function
  },
  transformImgUrl: {
    type: Function,
    default: (t) => t
  }
};
const ContentPreview = /* @__PURE__ */ defineComponent({
  name: "ContentPreview",
  props: contentPreviewProps,
  setup(props) {
    const editorId = inject("editorId");
    const previewTheme = inject("previewTheme");
    const showCodeRowNumber = inject("showCodeRowNumber");
    const {
      html,
      key
    } = useMarkdownIt$1(props, props.previewOnly);
    useCopyCode(props, html, key);
    userZoom(props, html);
    return () => {
      return createVNode(Fragment, null, [props.setting.preview && createVNode("div", {
        "id": `${editorId}-preview-wrapper`,
        "class": `${prefix}-preview-wrapper`,
        "key": "content-preview-wrapper"
      }, [createVNode("div", {
        "key": key.value,
        "id": `${editorId}-preview`,
        "class": [`${prefix}-preview`, `${previewTheme == null ? void 0 : previewTheme.value}-theme`, showCodeRowNumber && `${prefix}-scrn`],
        "innerHTML": html.value
      }, null)]), !props.previewOnly && props.setting.htmlPreview && createVNode("div", {
        "id": `${editorId}-html-wrapper`,
        "class": `${prefix}-preview-wrapper`,
        "key": "html-preview-wrapper"
      }, [createVNode("div", {
        "class": `${prefix}-html`
      }, [html.value])])]);
    };
  }
});
const useOnSave = (props, context) => {
  const { editorId } = props;
  const state = reactive({
    // 是否已编译成html
    buildFinished: false,
    // 存储当前最新的html
    html: ""
  });
  watch(
    () => props.modelValue,
    () => {
      state.buildFinished = false;
    }
  );
  onMounted(() => {
    bus.on(editorId, {
      name: BUILD_FINISHED,
      callback(html) {
        state.buildFinished = true;
        state.html = html;
      }
    });
    bus.on(editorId, {
      name: ON_SAVE,
      callback() {
        const htmlPromise = new Promise((rev) => {
          if (state.buildFinished) {
            rev(state.html);
          } else {
            const buildFinishedCallback = (html) => {
              rev(html);
              bus.remove(editorId, BUILD_FINISHED, buildFinishedCallback);
            };
            bus.on(editorId, {
              name: BUILD_FINISHED,
              callback: buildFinishedCallback
            });
          }
        });
        if (props.onSave) {
          props.onSave(props.modelValue, htmlPromise);
        } else {
          context.emit("onSave", props.modelValue, htmlPromise);
        }
      }
    });
  });
};
const useProvidePreview = (props) => {
  var _a, _b;
  const { editorId } = props;
  const highlightConfig = (_b = (_a = configOption) == null ? void 0 : _a.editorExtensions) == null ? void 0 : _b.highlight;
  provide("editorId", editorId);
  provide(
    "theme",
    computed(() => props.theme)
  );
  provide(
    "language",
    computed(() => props.language)
  );
  provide(
    "highlight",
    computed(() => {
      const cssList = {
        ...codeCss,
        ...highlightConfig == null ? void 0 : highlightConfig.css
      };
      const theme = props.codeStyleReverse && props.codeStyleReverseList.includes(props.previewTheme) ? "dark" : props.theme;
      return {
        js: (highlightConfig == null ? void 0 : highlightConfig.js) || highlightUrl,
        css: cssList[props.codeTheme] ? cssList[props.codeTheme][theme] : codeCss.atom[theme]
      };
    })
  );
  provide("showCodeRowNumber", props.showCodeRowNumber);
  const usedLanguageText = computed(() => {
    var _a2, _b2;
    const allText = {
      ...staticTextDefault,
      ...(_b2 = (_a2 = configOption) == null ? void 0 : _a2.editorConfig) == null ? void 0 : _b2.languageUserDefined
    };
    return deepMerge(
      deepClone(staticTextDefault["en-US"]),
      allText[props.language] || {}
    );
  });
  provide("usedLanguageText", usedLanguageText);
  provide(
    "previewTheme",
    computed(() => props.previewTheme)
  );
  provide(
    "customIcon",
    computed(() => props.customIcon)
  );
};
const useProvide = (props) => {
  useProvidePreview(props);
  provide("tabWidth", props.tabWidth);
};
const useExpansionPreview = (props) => {
  onMounted(() => {
    var _a, _b;
    if (!props.noIconfont) {
      if (configOption.iconfontType === "svg") {
        const iconfontScript = document.createElement("script");
        iconfontScript.src = ((_a = configOption.editorExtensions) == null ? void 0 : _a.iconfont) || iconfontSvgUrl;
        iconfontScript.id = `${prefix}-icon`;
        appendHandler(iconfontScript);
      } else {
        const iconfontLink = document.createElement("link");
        iconfontLink.rel = "stylesheet";
        iconfontLink.href = ((_b = configOption.editorExtensions) == null ? void 0 : _b.iconfontClass) || iconfontClassUrl;
        iconfontLink.id = `${prefix}-icon-class`;
        appendHandler(iconfontLink);
      }
    }
  });
};
const useExpansion = (props) => {
  var _a, _b, _c, _d, _e, _f;
  const { noPrettier, noUploadImg } = props;
  const { editorExtensions } = configOption;
  const noPrettierScript = noPrettier || !!((_b = (_a = configOption.editorExtensions) == null ? void 0 : _a.prettier) == null ? void 0 : _b.prettierInstance);
  const noParserMarkdownScript = noPrettier || !!((_d = (_c = configOption.editorExtensions) == null ? void 0 : _c.prettier) == null ? void 0 : _d.parserMarkdownInstance);
  const noCropperScript = noUploadImg || !!((_f = (_e = configOption.editorExtensions) == null ? void 0 : _e.cropper) == null ? void 0 : _f.instance);
  onMounted(() => {
    var _a2, _b2, _c2, _d2;
    const prettierScript = document.createElement("script");
    const prettierMDScript = document.createElement("script");
    prettierScript.src = ((_a2 = editorExtensions == null ? void 0 : editorExtensions.prettier) == null ? void 0 : _a2.standaloneJs) || prettierUrl.main;
    prettierScript.id = `${prefix}-prettier`;
    prettierMDScript.src = ((_b2 = editorExtensions == null ? void 0 : editorExtensions.prettier) == null ? void 0 : _b2.parserMarkdownJs) || prettierUrl.markdown;
    prettierMDScript.id = `${prefix}-prettierMD`;
    const cropperLink = document.createElement("link");
    cropperLink.rel = "stylesheet";
    cropperLink.href = ((_c2 = editorExtensions == null ? void 0 : editorExtensions.cropper) == null ? void 0 : _c2.css) || cropperUrl.css;
    cropperLink.id = `${prefix}-cropperCss`;
    const cropperScript = document.createElement("script");
    cropperScript.src = ((_d2 = editorExtensions == null ? void 0 : editorExtensions.cropper) == null ? void 0 : _d2.js) || cropperUrl.js;
    cropperScript.id = `${prefix}-cropper`;
    if (!noCropperScript) {
      appendHandler(cropperLink);
      appendHandler(cropperScript);
    }
    if (!noPrettierScript) {
      appendHandler(prettierScript);
    }
    if (!noParserMarkdownScript) {
      appendHandler(prettierMDScript);
    }
  });
  useExpansionPreview(props);
};
const useErrorCatcher = (props, context) => {
  const { editorId } = props;
  onMounted(() => {
    bus.on(editorId, {
      name: ERROR_CATCHER,
      callback: (err) => {
        if (props.onError instanceof Function) {
          props.onError(err);
        } else {
          context.emit("onError", err);
        }
      }
    });
  });
};
const useConfig = (props, context) => {
  const { editorId } = props;
  const setting = reactive({
    pageFullscreen: props.pageFullscreen,
    fullscreen: false,
    preview: props.preview,
    htmlPreview: props.preview ? false : props.htmlPreview,
    previewOnly: false
  });
  const updateSetting = (k, v) => {
    setting[k] = v === void 0 ? !setting[k] : v;
    if (k === "preview") {
      setting.htmlPreview = false;
      setting.previewOnly = false;
    } else if (k === "htmlPreview") {
      setting.preview = false;
      setting.previewOnly = false;
    } else if (k === "previewOnly" && !setting.preview && !setting.htmlPreview) {
      setting.preview = true;
    }
  };
  let bodyOverflowHistory = "";
  const adjustBody = () => {
    if (setting.pageFullscreen || setting.fullscreen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = bodyOverflowHistory;
    }
  };
  watch(() => [setting.pageFullscreen, setting.fullscreen], adjustBody);
  onMounted(() => {
    bus.on(editorId, {
      name: UPLOAD_IMAGE,
      callback(files, cb) {
        const insertHanlder = (urls) => {
          bus.emit(editorId, REPLACE, "image", {
            desc: "",
            urls
          });
          cb && cb();
        };
        if (props.onUploadImg) {
          props.onUploadImg(files, insertHanlder);
        } else {
          context.emit("onUploadImg", files, insertHanlder);
        }
      }
    });
    bodyOverflowHistory = document.body.style.overflow;
    adjustBody();
  });
  return [setting, updateSetting];
};
const useCatalog = (props) => {
  const { editorId } = props;
  const catalogShow = ref(false);
  onMounted(() => {
    bus.on(editorId, {
      name: CHANGE_CATALOG_VISIBLE,
      callback: (v) => {
        if (v === void 0) {
          catalogShow.value = !catalogShow.value;
        } else {
          catalogShow.value = v;
        }
      }
    });
  });
  const catalogVisible = computed(() => {
    return !props.toolbarsExclude.includes("catalog") && props.toolbars.includes("catalog") && catalogShow.value;
  });
  return catalogVisible;
};
const useExpose$1 = (props, ctx, catalogVisible, setting, updateSetting, codeRef) => {
  const { editorId } = props;
  watch(
    () => setting.pageFullscreen,
    (newVal) => {
      bus.emit(editorId, PAGE_FULL_SCREEN_CHANGED, newVal);
    }
  );
  watch(
    () => setting.fullscreen,
    (newVal) => {
      bus.emit(editorId, FULL_SCREEN_CHANGED, newVal);
    }
  );
  watch(
    () => setting.preview,
    (newVal) => {
      bus.emit(editorId, PREVIEW_CHANGED, newVal);
    }
  );
  watch(
    () => setting.previewOnly,
    (newVal) => {
      bus.emit(editorId, PREVIEW_ONLY_CHANGED, newVal);
    }
  );
  watch(
    () => setting.htmlPreview,
    (newVal) => {
      bus.emit(editorId, HTML_PREVIEW_CHANGED, newVal);
    }
  );
  watch(catalogVisible, (newVal) => {
    bus.emit(editorId, CATALOG_VISIBLE_CHANGED, newVal);
  });
  const exposeParam = {
    on(eventName, callBack) {
      switch (eventName) {
        case "pageFullscreen": {
          bus.on(editorId, {
            name: PAGE_FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "fullscreen": {
          bus.on(editorId, {
            name: FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "preview": {
          bus.on(editorId, {
            name: PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "previewOnly": {
          bus.on(editorId, {
            name: PREVIEW_ONLY_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "htmlPreview": {
          bus.on(editorId, {
            name: HTML_PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "catalog": {
          bus.on(editorId, {
            name: CATALOG_VISIBLE_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(status) {
      updateSetting("pageFullscreen", status);
    },
    toggleFullscreen(status) {
      bus.emit(editorId, CHANGE_FULL_SCREEN, status);
    },
    togglePreview(status) {
      updateSetting("preview", status);
    },
    togglePreviewOnly(status) {
      updateSetting("previewOnly", status);
    },
    toggleHtmlPreview(status) {
      updateSetting("htmlPreview", status);
    },
    toggleCatalog(status) {
      bus.emit(editorId, CHANGE_CATALOG_VISIBLE, status);
    },
    triggerSave() {
      bus.emit(editorId, ON_SAVE);
    },
    insert(generate) {
      bus.emit(editorId, REPLACE, "universal", { generate });
    },
    focus(options) {
      var _a;
      (_a = codeRef.value) == null ? void 0 : _a.focus(options);
    },
    rerender() {
      bus.emit(editorId, RERENDER);
    },
    getSelectedText() {
      var _a;
      return (_a = codeRef.value) == null ? void 0 : _a.getSelectedText();
    },
    resetHistory() {
      var _a;
      (_a = codeRef.value) == null ? void 0 : _a.resetHistory();
    },
    domEventHandlers(handlers) {
      bus.emit(editorId, EVENT_LISTENER, handlers);
    },
    execCommand(direct) {
      bus.emit(editorId, REPLACE, direct);
    }
  };
  ctx.expose(exposeParam);
};
const mdHeadingId = (text) => text;
const mdPreviewProps = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: () => getNextId("md-editor-v3_")
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: false
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: mdHeadingId
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (html) => html
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: false
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: false
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: true
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: false
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (h) => Promise.resolve(h)
  }
};
const editorProps = {
  ...mdPreviewProps,
  /**
   * input回调事件
   */
  onChange: {
    type: Function
  },
  /**
   * input回调事件
   */
  onSave: {
    type: Function
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: false
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: true
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: false
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: allToolbar
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: false
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object]
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: allFooter
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: true
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object]
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: false
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWitdh: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  onInputBoxWitdhChange: {
    type: Function
  },
  /**
   * 替换粘贴的图片链接
   *
   * @param t 图片链接
   * @returns
   */
  transformImgUrl: {
    type: Function,
    default: (t) => t
  }
};
const mdPreviewEmits = ["onHtmlChanged", "onGetCatalog"];
const editorEmits = [
  ...mdPreviewEmits,
  "onChange",
  "onSave",
  "onUploadImg",
  "onError",
  "update:modelValue",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "onInputBoxWitdhChange"
];
const useExpose = (props, ctx) => {
  const { editorId } = props;
  const exposeParam = {
    rerender() {
      bus.emit(editorId, RERENDER);
    }
  };
  ctx.expose(exposeParam);
};
const MdPreview = /* @__PURE__ */ defineComponent({
  name: "MdPreview",
  props: mdPreviewProps,
  emits: mdPreviewEmits,
  setup(props, ctx) {
    const {
      editorId,
      noKatex,
      noMermaid,
      noHighlight
    } = props;
    useProvidePreview(props);
    useExpansionPreview(props);
    useExpose(props, ctx);
    onBeforeUnmount(() => {
      bus.clear(editorId);
    });
    return () => {
      return createVNode("div", {
        "id": editorId,
        "class": [prefix, props.class, props.theme === "dark" && `${prefix}-dark`, `${prefix}-previewOnly`],
        "style": props.style
      }, [createVNode(ContentPreview, {
        "modelValue": props.modelValue,
        "onHtmlChanged": (html) => {
          if (props.onHtmlChanged) {
            props.onHtmlChanged(html);
          } else {
            ctx.emit("onHtmlChanged", html);
          }
        },
        "onGetCatalog": (list) => {
          if (props.onGetCatalog) {
            props.onGetCatalog(list);
          } else {
            ctx.emit("onGetCatalog", list);
          }
        },
        "mdHeadingId": props.mdHeadingId,
        "noMermaid": noMermaid,
        "sanitize": props.sanitize,
        "noKatex": noKatex,
        "formatCopiedText": props.formatCopiedText,
        "noHighlight": noHighlight,
        "noImgZoomIn": props.noImgZoomIn,
        "previewOnly": true,
        "sanitizeMermaid": props.sanitizeMermaid
      }, null)]);
    };
  }
});
MdPreview.install = (app) => {
  app.component(MdPreview.name, MdPreview);
  return app;
};
export {
  ContentPreview as C,
  MdPreview as M,
  editorEmits as a,
  useProvide as b,
  contentProps as c,
  useExpansion as d,
  editorProps as e,
  useErrorCatcher as f,
  useConfig as g,
  useCatalog as h,
  useExpose$1 as i,
  useOnSave as u
};
