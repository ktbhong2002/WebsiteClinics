"use strict";
const vue = require("vue");
const config = require("./config.cjs");
const index = require("./index4.cjs");
const dom = require("./dom.cjs");
const util = require("@vavt/util");
const mediumZoom = require("medium-zoom");
const copy = require("copy-to-clipboard");
const mdit = require("markdown-it");
const ImageFiguresPlugin = require("markdown-it-image-figures");
const TaskListPlugin = require("markdown-it-task-lists");
const XSSPlugin = require("markdown-it-xss");
const lruCache = require("lru-cache");
const userZoom = (props, html) => {
  const editorId = vue.inject("editorId");
  const { noImgZoomIn } = props;
  let zoomHander = () => {
  };
  vue.watch(
    [html, vue.toRef(props.setting, "preview")],
    () => {
      if (!noImgZoomIn && props.setting.preview) {
        zoomHander();
      }
    },
    {
      immediate: true
    }
  );
  vue.onMounted(() => {
    zoomHander = util.debounce(() => {
      const imgs = document.querySelectorAll(`#${editorId}-preview img`);
      if (imgs.length === 0) {
        return;
      }
      mediumZoom(imgs, {
        background: "#00000073"
      });
    });
  });
};
const StrIcon = (name, customIcon) => {
  if (typeof customIcon[name] === "string") {
    return customIcon[name];
  }
  const defaultStr = `<i class="${config.prefix}-iconfont ${config.prefix}-icon-${name}"></i>`;
  switch (config.configOption.iconfontType) {
    case "svg": {
      return `<svg class="${config.prefix}-icon" aria-hidden="true"><use xlink:href="#${config.prefix}-icon-${name}"></use></svg>`;
    }
    default: {
      return defaultStr;
    }
  }
};
const useCopyCode = (props, html, key) => {
  const editorId = vue.inject("editorId");
  const ult = vue.inject("usedLanguageText");
  const customIcon = vue.inject("customIcon");
  const initCopyEntry = () => {
    document.querySelectorAll(`#${editorId}-preview pre`).forEach((pre) => {
      var _a, _b;
      let clearTimer = -1;
      (_a = pre.querySelector(".copy-button")) == null ? void 0 : _a.remove();
      const copyBtnText = ((_b = ult.value.copyCode) == null ? void 0 : _b.text) || "复制代码";
      const copyButton = document.createElement("span");
      copyButton.setAttribute("class", "copy-button");
      copyButton.dataset.tips = copyBtnText;
      copyButton.innerHTML = StrIcon("copy", customIcon.value);
      copyButton.addEventListener("click", () => {
        var _a2, _b2;
        clearTimeout(clearTimer);
        const codeText = pre.querySelector("code").innerText;
        const success = copy(props.formatCopiedText(codeText));
        const succssTip = ((_a2 = ult.value.copyCode) == null ? void 0 : _a2.successTips) || "已复制！";
        const failTip = ((_b2 = ult.value.copyCode) == null ? void 0 : _b2.failTips) || "已复制！";
        copyButton.dataset.tips = success ? succssTip : failTip;
        clearTimer = window.setTimeout(() => {
          copyButton.dataset.tips = copyBtnText;
        }, 1500);
      });
      pre.appendChild(copyButton);
    });
  };
  const htmlChanged = () => {
    vue.nextTick(initCopyEntry);
  };
  const settingPreviewChanged = (nVal) => {
    if (nVal) {
      vue.nextTick(initCopyEntry);
    }
  };
  vue.watch([html, key], htmlChanged);
  vue.watch(() => props.setting.preview, settingPreviewChanged);
  vue.watch(() => props.setting.htmlPreview, settingPreviewChanged);
  vue.watch(() => ult.value, initCopyEntry);
  vue.onMounted(initCopyEntry);
};
const useHighlight = (props) => {
  var _a;
  const hljsConf = (_a = config.configOption.editorExtensions) == null ? void 0 : _a.highlight;
  const hljs = hljsConf == null ? void 0 : hljsConf.instance;
  const highlightUrl = vue.inject("highlight");
  const hljsRef = vue.shallowRef(hljs);
  vue.onMounted(() => {
    if (props.noHighlight) {
      return;
    }
    if (!hljsRef.value) {
      const highlightScript = document.createElement("script");
      highlightScript.src = highlightUrl.value.js;
      highlightScript.onload = () => {
        hljsRef.value = window.hljs;
      };
      highlightScript.id = `${config.prefix}-hljs`;
      dom.appendHandler(highlightScript, "hljs");
      const highlightLink = document.createElement("link");
      highlightLink.rel = "stylesheet";
      highlightLink.href = highlightUrl.value.css;
      highlightLink.id = `${config.prefix}-hlCss`;
      dom.appendHandler(highlightLink);
    }
  });
  vue.watch(
    () => highlightUrl.value.css,
    (url) => {
      dom.updateHandler(`${config.prefix}-hlCss`, "href", url);
    }
  );
  return hljsRef;
};
const useMermaid = (props) => {
  const theme = vue.inject("theme");
  const { editorExtensions, mermaidConfig } = config.configOption;
  const mermaidConf = editorExtensions == null ? void 0 : editorExtensions.mermaid;
  const mermaidRef = vue.shallowRef(mermaidConf == null ? void 0 : mermaidConf.instance);
  const reRenderRef = vue.shallowRef(-1);
  const mermaidCache = new lruCache.LRUCache({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  });
  const configMermaid = () => {
    const mermaid = mermaidRef.value;
    if (!props.noMermaid && mermaid) {
      mermaid.initialize(
        mermaidConfig({
          startOnLoad: false,
          theme: theme.value === "dark" ? "dark" : "default"
        })
      );
      reRenderRef.value = reRenderRef.value + 1;
    }
  };
  vue.watch(
    () => theme.value,
    () => {
      mermaidCache.clear();
      configMermaid();
    }
  );
  vue.onMounted(() => {
    if (props.noMermaid) {
      return;
    }
    if (!(mermaidConf == null ? void 0 : mermaidConf.instance)) {
      const jsSrc = (mermaidConf == null ? void 0 : mermaidConf.js) || config.mermaidUrl;
      if (/\.mjs/.test(jsSrc)) {
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          jsSrc
        ).then((module2) => {
          mermaidRef.value = module2.default;
          configMermaid();
        });
      } else {
        const mermaidScript = document.createElement("script");
        mermaidScript.id = `${config.prefix}-mermaid`;
        mermaidScript.src = jsSrc;
        mermaidScript.onload = () => {
          mermaidRef.value = window.mermaid;
          configMermaid();
        };
        dom.appendHandler(mermaidScript, "mermaid");
      }
    }
  });
  const replaceMermaid = () => {
    vue.nextTick(() => {
      if (!props.noMermaid && mermaidRef.value) {
        const mermaidSourceEles = document.querySelectorAll(
          `div.${config.prefix}-mermaid`
        );
        const svgContainingElement = document.createElement("div");
        svgContainingElement.style.width = document.body.offsetWidth + "px";
        svgContainingElement.style.height = document.body.offsetHeight + "px";
        svgContainingElement.style.position = "fixed";
        svgContainingElement.style.zIndex = "-10000";
        svgContainingElement.style.top = "-10000";
        let count = mermaidSourceEles.length;
        if (count > 0) {
          document.body.appendChild(svgContainingElement);
        }
        mermaidSourceEles.forEach(async (item) => {
          let mermaidHtml = mermaidCache.get(item.innerText);
          if (!mermaidHtml) {
            const idRand = util.uuid();
            const render = mermaidRef.value.renderAsync || mermaidRef.value.render;
            let svg = "";
            try {
              svg = await render(idRand, item.innerText, svgContainingElement);
            } catch (error) {
            }
            mermaidHtml = await props.sanitizeMermaid(
              typeof svg === "string" ? svg : svg.svg
            );
            mermaidCache.set(item.innerText, mermaidHtml);
          }
          const p = document.createElement("p");
          p.className = `${config.prefix}-mermaid`;
          p.setAttribute("data-processed", "");
          p.innerHTML = mermaidHtml;
          if (item.dataset.line !== void 0) {
            p.dataset.line = item.dataset.line;
          }
          item.replaceWith(p);
          if (--count === 0) {
            svgContainingElement.remove();
          }
        });
      }
    });
  };
  return { mermaidRef, reRenderRef, replaceMermaid };
};
const useKatex = (props) => {
  var _a;
  const katexConf = (_a = config.configOption.editorExtensions) == null ? void 0 : _a.katex;
  const katexIns = katexConf == null ? void 0 : katexConf.instance;
  const katex = vue.shallowRef(katexIns);
  vue.onMounted(() => {
    if (!props.noKatex && !katex.value) {
      const katexScript = document.createElement("script");
      katexScript.src = (katexConf == null ? void 0 : katexConf.js) || config.katexUrl.js;
      katexScript.onload = () => {
        katex.value = window.katex;
      };
      katexScript.id = `${config.prefix}-katex`;
      const katexLink = document.createElement("link");
      katexLink.rel = "stylesheet";
      katexLink.href = (katexConf == null ? void 0 : katexConf.css) || config.katexUrl.css;
      katexLink.id = `${config.prefix}-katexCss`;
      dom.appendHandler(katexScript, "katex");
      dom.appendHandler(katexLink);
    }
  });
  return katex;
};
const MermaidPlugin = (md, options) => {
  const temp = md.renderer.rules.fence.bind(md.renderer.rules);
  md.renderer.rules.fence = (tokens, idx, ops, env, slf) => {
    const token = tokens[idx];
    const code = token.content.trim();
    if (token.info === "mermaid") {
      let line;
      if (tokens[idx].map && tokens[idx].level === 0) {
        line = tokens[idx].map[0];
        tokens[idx].attrSet("data-line", String(line));
      }
      return `<div class="${config.prefix}-mermaid" ${line !== void 0 ? "data-line=" + line : ""} data-mermaid-theme=${options.themeRef.value}>${code}</div>`;
    }
    return temp(tokens, idx, ops, env, slf);
  };
};
const MermaidPlugin$1 = MermaidPlugin;
const isValidDelim = (state, pos) => {
  let can_open = true, can_close = true;
  const max = state.posMax;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57) {
    can_close = false;
  }
  if (nextChar === 32 || nextChar === 9) {
    can_open = false;
  }
  return {
    can_open,
    can_close
  };
};
const math_inline = (state, silent) => {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$") {
    return false;
  }
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\") {
      pos -= 1;
    }
    if ((match - pos) % 2 == 1) {
      break;
    }
    match += 1;
  }
  if (match === -1) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent) {
      state.pending += "$$";
    }
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent) {
      state.pending += "$";
    }
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
};
const math_block = (state, start, end, silent) => {
  let firstLine, lastLine, next, lastPos, found = false, pos = state.bMarks[start] + state.tShift[start], max = state.eMarks[start];
  if (pos + 2 > max) {
    return false;
  }
  if (state.src.slice(pos, pos + 2) !== "$$") {
    return false;
  }
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent) {
    return true;
  }
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end) {
      break;
    }
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
};
const KatexPlugin = (md, options) => {
  const katexInline = (str) => {
    if (options.katexRef.value) {
      const html = options.katexRef.value.renderToString(str, {
        throwOnError: false
      });
      return `<span class="${config.prefix}-katex-inline" data-processed>${html}</span>`;
    } else {
      return `<span class="${config.prefix}-katex-inline">${str}</span>`;
    }
  };
  const katexBlock = (str, lineNum) => {
    if (options.katexRef.value) {
      const html = options.katexRef.value.renderToString(str, {
        throwOnError: false,
        displayMode: true
      });
      return `<p class="${config.prefix}-katex-block" data-line=${lineNum} data-processed>${html}</p>`;
    } else {
      return `<p class="${config.prefix}-katex-block" data-line=${lineNum}>${str}</p>`;
    }
  };
  md.inline.ruler.after("escape", "math_inline", math_inline);
  md.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md.renderer.rules.math_inline = (tokens, idx) => {
    return katexInline(tokens[idx].content);
  };
  md.renderer.rules.math_block = (tokens, idx) => {
    return katexBlock(tokens[idx].content, tokens[idx].map[0]) + "\n";
  };
};
const KatexPlugin$1 = KatexPlugin;
const AdmonitionPlugin = (md, options) => {
  options = options || {};
  const markers = 3, markerStr = options.marker || "!", markerChar = markerStr.charCodeAt(0), markerLen = markerStr.length;
  let type = "", title = "";
  const render = (tokens, idx, _options, _env, self) => {
    const token = tokens[idx];
    if (token.type === "admonition_open") {
      tokens[idx].attrPush([
        "class",
        `${config.prefix}-admonition ${config.prefix}-admonition-${token.info}`
      ]);
      tokens[idx].attrSet("data-line", String(tokens[idx].map[0]));
    } else if (token.type === "admonition_title_open") {
      tokens[idx].attrPush(["class", `${config.prefix}-admonition-title`]);
    }
    return self.renderToken(tokens, idx, _options);
  };
  const validate = (params) => {
    const array = params.trim().split(" ", 2);
    title = "";
    type = array[0];
    if (array.length > 1) {
      title = params.substring(type.length + 2);
    }
    if (title === "" || !title) {
      title = type;
    }
  };
  md.block.ruler.before(
    "code",
    "admonition",
    (state, startLine, endLine, silent) => {
      let pos, nextLine, token, autoClosed = false, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (markerChar !== state.src.charCodeAt(start)) {
        return false;
      }
      for (pos = start + 1; pos <= max; pos++) {
        if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
          break;
        }
      }
      const markerCount = Math.floor((pos - start) / markerLen);
      if (markerCount !== markers) {
        return false;
      }
      pos -= (pos - start) % markerLen;
      const markup = state.src.slice(start, pos);
      const params = state.src.slice(pos, max);
      validate(params);
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (start < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (markerChar !== state.src.charCodeAt(start)) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        for (pos = start + 1; pos <= max; pos++) {
          if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
            break;
          }
        }
        if (Math.floor((pos - start) / markerLen) < markerCount) {
          continue;
        }
        pos -= (pos - start) % markerLen;
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        autoClosed = true;
        break;
      }
      const oldParent = state.parentType;
      const oldLineMax = state.lineMax;
      state.parentType = "root";
      state.lineMax = nextLine;
      token = state.push("admonition_open", "div", 1);
      token.markup = markup;
      token.block = true;
      token.info = type;
      token.map = [startLine, nextLine];
      token = state.push("admonition_title_open", "p", 1);
      token.markup = markup + " " + type;
      token.map = [startLine, nextLine];
      token = state.push("inline", "", 0);
      token.content = title;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("admonition_title_close", "p", -1);
      token.markup = markup + " " + type;
      state.md.block.tokenize(state, startLine + 1, nextLine);
      token = state.push("admonition_close", "div", -1);
      token.markup = state.src.slice(start, pos);
      token.block = true;
      state.parentType = oldParent;
      state.lineMax = oldLineMax;
      state.line = nextLine + (autoClosed ? 1 : 0);
      return true;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  );
  md.renderer.rules["admonition_open"] = render;
  md.renderer.rules["admonition_title_open"] = render;
  md.renderer.rules["admonition_title_close"] = render;
  md.renderer.rules["admonition_close"] = render;
};
const AdmonitionPlugin$1 = AdmonitionPlugin;
const HeadingPlugin = (md, options) => {
  md.renderer.rules.heading_open = (tokens, idx) => {
    var _a;
    const token = tokens[idx];
    const text = ((_a = tokens[idx + 1].children) == null ? void 0 : _a.reduce((p, c) => {
      return p + (c.content || "");
    }, "")) || "";
    const level = token.markup.length;
    options.headsRef.value.push({
      text,
      level
    });
    if (token.map && token.level === 0) {
      token.attrSet("data-line", String(token.map[0]));
      token.attrSet(
        "id",
        options.mdHeadingId(text, level, options.headsRef.value.length)
      );
    }
    return md.renderer.renderToken(tokens, idx, options);
  };
  md.renderer.rules.heading_close = (tokens, idx, opts, _env, self) => {
    return self.renderToken(tokens, idx, opts);
  };
};
const HeadingPlugin$1 = HeadingPlugin;
const codetabs = (md, _opts) => {
  const defaultRender = md.renderer.rules.fence, unescapeAll = md.utils.unescapeAll, re = /\[(\w*)(?::([\w ]*))?\]/;
  function getInfo(token) {
    return token.info ? unescapeAll(token.info).trim() : "";
  }
  function getGroupAndTab(token) {
    const info = getInfo(token), [group = null, tab = ""] = (re.exec(info) || []).slice(1);
    return [group, tab];
  }
  function getLangName(token) {
    const info = getInfo(token);
    return info ? info.split(/(\s+)/g)[0] : "";
  }
  const fenceGroup = (tokens, idx, options, env, slf) => {
    if (tokens[idx].hidden) {
      return "";
    }
    const [GROUP, _] = getGroupAndTab(tokens[idx]);
    if (GROUP === null) {
      return defaultRender(tokens, idx, options, env, slf);
    }
    let token, group, tab, checked, labels = "", pres = "";
    for (let i = idx; i < tokens.length; i++) {
      token = tokens[i];
      [group, tab] = getGroupAndTab(token);
      if (group !== GROUP) {
        break;
      }
      token.info = token.info.replace(re, "");
      token.hidden = true;
      checked = i - idx > 0 ? "" : " checked";
      labels += `<li><input type="radio" name="label-group-${_opts.editorId}-${idx}"${checked}><label for="group-${_opts.editorId}-${idx}-tab-${i - idx}" onclick="this.previousElementSibling.click()">${tab || getLangName(token)}</label></li>
`;
      pres += `<input type="radio" id="group-${_opts.editorId}-${idx}-tab-${i - idx}" name="group-${_opts.editorId}-${idx}"${checked}>
` + defaultRender(tokens, i, options, env, slf);
    }
    return '<div class="code-tabs">\n<ul>\n' + labels + "</ul>\n" + pres + "</div>";
  };
  md.renderer.rules.fence = fenceGroup;
};
const CodeTabsPlugin = codetabs;
const initLineNumber = (md) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((rule) => {
    const backup = md.renderer.rules[rule];
    if (!backup) {
      md.renderer.rules[rule] = (tokens, idx, options, _env, self) => {
        let line;
        if (tokens[idx].map && tokens[idx].level === 0) {
          line = tokens[idx].map[0];
          tokens[idx].attrSet("data-line", String(line));
        }
        return self.renderToken(tokens, idx, options);
      };
    } else {
      md.renderer.rules[rule] = (tokens, idx, options, env, self) => {
        let line;
        const _htmlCode = backup(tokens, idx, options, env, self);
        if (tokens[idx].map && tokens[idx].level === 0 && !/^<!--/.test(_htmlCode)) {
          line = tokens[idx].map[0];
          return _htmlCode.replace(/^(<[^>]*)/, `$1 data-line="${line}"`);
        }
        return _htmlCode;
      };
    }
  });
};
const useMarkdownIt = (props, previewOnly) => {
  const { editorConfig, markdownItConfig, markdownItPlugins } = config.configOption;
  const editorId = vue.inject("editorId");
  const showCodeRowNumber = vue.inject("showCodeRowNumber");
  const themeRef = vue.inject("theme");
  const headsRef = vue.ref([]);
  const hljsRef = useHighlight(props);
  const katexRef = useKatex(props);
  const { reRenderRef, replaceMermaid } = useMermaid(props);
  const md = mdit({
    html: true,
    breaks: true
  });
  markdownItConfig(md, {
    editorId
  });
  const plugins = [
    {
      type: "katex",
      plugin: KatexPlugin$1,
      options: { katexRef }
    },
    {
      type: "image",
      plugin: ImageFiguresPlugin,
      options: { figcaption: true, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: AdmonitionPlugin$1,
      options: {}
    },
    {
      type: "taskList",
      plugin: TaskListPlugin,
      options: {}
    },
    {
      type: "heading",
      plugin: HeadingPlugin$1,
      options: { mdHeadingId: props.mdHeadingId, headsRef }
    },
    {
      type: "codeTabs",
      plugin: CodeTabsPlugin,
      options: { editorId }
    },
    {
      type: "xss",
      plugin: XSSPlugin,
      options: {
        // https://github.com/leizongmin/js-xss/blob/master/README.zh.md
        xss(xss) {
          return {
            whiteList: Object.assign({}, xss.getDefaultWhiteList(), {
              // 支持任务列表
              input: ["class", "disabled", "type", "checked"],
              // 主要支持youtobe、腾讯视频、哔哩哔哩等内嵌视频代码
              iframe: [
                "class",
                "width",
                "height",
                "src",
                "title",
                "border",
                "frameborder",
                "framespacing",
                "allow",
                "allowfullscreen"
              ]
            })
          };
        }
      }
    }
  ];
  if (!props.noMermaid) {
    plugins.push({
      type: "mermaid",
      plugin: MermaidPlugin$1,
      options: { themeRef }
    });
  }
  markdownItPlugins(plugins, {
    editorId
  }).forEach((item) => {
    md.use(item.plugin, item.options);
  });
  const userDefHighlight = md.options.highlight;
  md.set({
    highlight: (str, language, attrs) => {
      if (userDefHighlight) {
        const result = userDefHighlight(str, language, attrs);
        if (result) {
          return result;
        }
      }
      let codeHtml;
      if (!props.noHighlight && hljsRef.value) {
        const hljsLang = hljsRef.value.getLanguage(language);
        if (hljsLang) {
          codeHtml = hljsRef.value.highlight(str, {
            language,
            ignoreIllegals: true
          }).value;
        } else {
          codeHtml = hljsRef.value.highlightAuto(str).value;
        }
      } else {
        codeHtml = md.utils.escapeHtml(str);
      }
      const codeSpan = showCodeRowNumber ? index.generateCodeRowNumber(codeHtml.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${codeHtml.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${language}" language=${language}>${codeSpan}</code></pre>`;
    }
  });
  initLineNumber(md);
  const key = vue.ref(`_article-key_${util.uuid()}`);
  const html = vue.ref(props.sanitize(md.render(props.modelValue)));
  const updatedTodo = () => {
    index.bus.emit(editorId, index.BUILD_FINISHED, html.value);
    props.onHtmlChanged(html.value);
    props.onGetCatalog(headsRef.value);
    index.bus.emit(editorId, index.CATALOG_CHANGED, headsRef.value);
    replaceMermaid();
  };
  vue.onMounted(updatedTodo);
  const markHtml = () => {
    headsRef.value = [];
    html.value = props.sanitize(md.render(props.modelValue));
    updatedTodo();
  };
  const needReRender = vue.computed(() => {
    return (props.noKatex || katexRef.value) && (props.noHighlight || hljsRef.value);
  });
  vue.watch(
    [vue.toRef(props, "modelValue"), needReRender, reRenderRef],
    util.debounce(
      markHtml,
      (editorConfig == null ? void 0 : editorConfig.renderDelay) !== void 0 ? editorConfig == null ? void 0 : editorConfig.renderDelay : previewOnly ? 0 : 500
    )
  );
  vue.onMounted(() => {
    index.bus.on(editorId, {
      name: index.PUSH_CATALOG,
      callback() {
        index.bus.emit(editorId, index.CATALOG_CHANGED, headsRef.value);
      }
    });
    index.bus.on(editorId, {
      name: index.RERENDER,
      callback: () => {
        markHtml();
        key.value = `_article-key_${util.uuid()}`;
      }
    });
  });
  return { html, key };
};
const useMarkdownIt$1 = useMarkdownIt;
const contentPreviewProps = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({ preview: true })
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: false
  },
  sanitize: {
    type: Function,
    default: (html) => html
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: false
  },
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  previewOnly: {
    type: Boolean,
    default: false
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  }
};
const contentProps = {
  ...contentPreviewProps,
  updateModelValue: {
    type: Function,
    default: () => {
    }
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: "light"
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWitdh: {
    type: String
  },
  onInputBoxWitdhChange: {
    type: Function
  },
  transformImgUrl: {
    type: Function,
    default: (t) => t
  }
};
const ContentPreview = /* @__PURE__ */ vue.defineComponent({
  name: "ContentPreview",
  props: contentPreviewProps,
  setup(props) {
    const editorId = vue.inject("editorId");
    const previewTheme = vue.inject("previewTheme");
    const showCodeRowNumber = vue.inject("showCodeRowNumber");
    const {
      html,
      key
    } = useMarkdownIt$1(props, props.previewOnly);
    useCopyCode(props, html, key);
    userZoom(props, html);
    return () => {
      return vue.createVNode(vue.Fragment, null, [props.setting.preview && vue.createVNode("div", {
        "id": `${editorId}-preview-wrapper`,
        "class": `${config.prefix}-preview-wrapper`,
        "key": "content-preview-wrapper"
      }, [vue.createVNode("div", {
        "key": key.value,
        "id": `${editorId}-preview`,
        "class": [`${config.prefix}-preview`, `${previewTheme == null ? void 0 : previewTheme.value}-theme`, showCodeRowNumber && `${config.prefix}-scrn`],
        "innerHTML": html.value
      }, null)]), !props.previewOnly && props.setting.htmlPreview && vue.createVNode("div", {
        "id": `${editorId}-html-wrapper`,
        "class": `${config.prefix}-preview-wrapper`,
        "key": "html-preview-wrapper"
      }, [vue.createVNode("div", {
        "class": `${config.prefix}-html`
      }, [html.value])])]);
    };
  }
});
const useOnSave = (props, context) => {
  const { editorId } = props;
  const state = vue.reactive({
    // 是否已编译成html
    buildFinished: false,
    // 存储当前最新的html
    html: ""
  });
  vue.watch(
    () => props.modelValue,
    () => {
      state.buildFinished = false;
    }
  );
  vue.onMounted(() => {
    index.bus.on(editorId, {
      name: index.BUILD_FINISHED,
      callback(html) {
        state.buildFinished = true;
        state.html = html;
      }
    });
    index.bus.on(editorId, {
      name: index.ON_SAVE,
      callback() {
        const htmlPromise = new Promise((rev) => {
          if (state.buildFinished) {
            rev(state.html);
          } else {
            const buildFinishedCallback = (html) => {
              rev(html);
              index.bus.remove(editorId, index.BUILD_FINISHED, buildFinishedCallback);
            };
            index.bus.on(editorId, {
              name: index.BUILD_FINISHED,
              callback: buildFinishedCallback
            });
          }
        });
        if (props.onSave) {
          props.onSave(props.modelValue, htmlPromise);
        } else {
          context.emit("onSave", props.modelValue, htmlPromise);
        }
      }
    });
  });
};
const useProvidePreview = (props) => {
  var _a, _b;
  const { editorId } = props;
  const highlightConfig = (_b = (_a = config.configOption) == null ? void 0 : _a.editorExtensions) == null ? void 0 : _b.highlight;
  vue.provide("editorId", editorId);
  vue.provide(
    "theme",
    vue.computed(() => props.theme)
  );
  vue.provide(
    "language",
    vue.computed(() => props.language)
  );
  vue.provide(
    "highlight",
    vue.computed(() => {
      const cssList = {
        ...config.codeCss,
        ...highlightConfig == null ? void 0 : highlightConfig.css
      };
      const theme = props.codeStyleReverse && props.codeStyleReverseList.includes(props.previewTheme) ? "dark" : props.theme;
      return {
        js: (highlightConfig == null ? void 0 : highlightConfig.js) || config.highlightUrl,
        css: cssList[props.codeTheme] ? cssList[props.codeTheme][theme] : config.codeCss.atom[theme]
      };
    })
  );
  vue.provide("showCodeRowNumber", props.showCodeRowNumber);
  const usedLanguageText = vue.computed(() => {
    var _a2, _b2;
    const allText = {
      ...config.staticTextDefault,
      ...(_b2 = (_a2 = config.configOption) == null ? void 0 : _a2.editorConfig) == null ? void 0 : _b2.languageUserDefined
    };
    return util.deepMerge(
      util.deepClone(config.staticTextDefault["en-US"]),
      allText[props.language] || {}
    );
  });
  vue.provide("usedLanguageText", usedLanguageText);
  vue.provide(
    "previewTheme",
    vue.computed(() => props.previewTheme)
  );
  vue.provide(
    "customIcon",
    vue.computed(() => props.customIcon)
  );
};
const useProvide = (props) => {
  useProvidePreview(props);
  vue.provide("tabWidth", props.tabWidth);
};
const useExpansionPreview = (props) => {
  vue.onMounted(() => {
    var _a, _b;
    if (!props.noIconfont) {
      if (config.configOption.iconfontType === "svg") {
        const iconfontScript = document.createElement("script");
        iconfontScript.src = ((_a = config.configOption.editorExtensions) == null ? void 0 : _a.iconfont) || config.iconfontSvgUrl;
        iconfontScript.id = `${config.prefix}-icon`;
        dom.appendHandler(iconfontScript);
      } else {
        const iconfontLink = document.createElement("link");
        iconfontLink.rel = "stylesheet";
        iconfontLink.href = ((_b = config.configOption.editorExtensions) == null ? void 0 : _b.iconfontClass) || config.iconfontClassUrl;
        iconfontLink.id = `${config.prefix}-icon-class`;
        dom.appendHandler(iconfontLink);
      }
    }
  });
};
const useExpansion = (props) => {
  var _a, _b, _c, _d, _e, _f;
  const { noPrettier, noUploadImg } = props;
  const { editorExtensions } = config.configOption;
  const noPrettierScript = noPrettier || !!((_b = (_a = config.configOption.editorExtensions) == null ? void 0 : _a.prettier) == null ? void 0 : _b.prettierInstance);
  const noParserMarkdownScript = noPrettier || !!((_d = (_c = config.configOption.editorExtensions) == null ? void 0 : _c.prettier) == null ? void 0 : _d.parserMarkdownInstance);
  const noCropperScript = noUploadImg || !!((_f = (_e = config.configOption.editorExtensions) == null ? void 0 : _e.cropper) == null ? void 0 : _f.instance);
  vue.onMounted(() => {
    var _a2, _b2, _c2, _d2;
    const prettierScript = document.createElement("script");
    const prettierMDScript = document.createElement("script");
    prettierScript.src = ((_a2 = editorExtensions == null ? void 0 : editorExtensions.prettier) == null ? void 0 : _a2.standaloneJs) || config.prettierUrl.main;
    prettierScript.id = `${config.prefix}-prettier`;
    prettierMDScript.src = ((_b2 = editorExtensions == null ? void 0 : editorExtensions.prettier) == null ? void 0 : _b2.parserMarkdownJs) || config.prettierUrl.markdown;
    prettierMDScript.id = `${config.prefix}-prettierMD`;
    const cropperLink = document.createElement("link");
    cropperLink.rel = "stylesheet";
    cropperLink.href = ((_c2 = editorExtensions == null ? void 0 : editorExtensions.cropper) == null ? void 0 : _c2.css) || config.cropperUrl.css;
    cropperLink.id = `${config.prefix}-cropperCss`;
    const cropperScript = document.createElement("script");
    cropperScript.src = ((_d2 = editorExtensions == null ? void 0 : editorExtensions.cropper) == null ? void 0 : _d2.js) || config.cropperUrl.js;
    cropperScript.id = `${config.prefix}-cropper`;
    if (!noCropperScript) {
      dom.appendHandler(cropperLink);
      dom.appendHandler(cropperScript);
    }
    if (!noPrettierScript) {
      dom.appendHandler(prettierScript);
    }
    if (!noParserMarkdownScript) {
      dom.appendHandler(prettierMDScript);
    }
  });
  useExpansionPreview(props);
};
const useErrorCatcher = (props, context) => {
  const { editorId } = props;
  vue.onMounted(() => {
    index.bus.on(editorId, {
      name: index.ERROR_CATCHER,
      callback: (err) => {
        if (props.onError instanceof Function) {
          props.onError(err);
        } else {
          context.emit("onError", err);
        }
      }
    });
  });
};
const useConfig = (props, context) => {
  const { editorId } = props;
  const setting = vue.reactive({
    pageFullscreen: props.pageFullscreen,
    fullscreen: false,
    preview: props.preview,
    htmlPreview: props.preview ? false : props.htmlPreview,
    previewOnly: false
  });
  const updateSetting = (k, v) => {
    setting[k] = v === void 0 ? !setting[k] : v;
    if (k === "preview") {
      setting.htmlPreview = false;
      setting.previewOnly = false;
    } else if (k === "htmlPreview") {
      setting.preview = false;
      setting.previewOnly = false;
    } else if (k === "previewOnly" && !setting.preview && !setting.htmlPreview) {
      setting.preview = true;
    }
  };
  let bodyOverflowHistory = "";
  const adjustBody = () => {
    if (setting.pageFullscreen || setting.fullscreen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = bodyOverflowHistory;
    }
  };
  vue.watch(() => [setting.pageFullscreen, setting.fullscreen], adjustBody);
  vue.onMounted(() => {
    index.bus.on(editorId, {
      name: index.UPLOAD_IMAGE,
      callback(files, cb) {
        const insertHanlder = (urls) => {
          index.bus.emit(editorId, index.REPLACE, "image", {
            desc: "",
            urls
          });
          cb && cb();
        };
        if (props.onUploadImg) {
          props.onUploadImg(files, insertHanlder);
        } else {
          context.emit("onUploadImg", files, insertHanlder);
        }
      }
    });
    bodyOverflowHistory = document.body.style.overflow;
    adjustBody();
  });
  return [setting, updateSetting];
};
const useCatalog = (props) => {
  const { editorId } = props;
  const catalogShow = vue.ref(false);
  vue.onMounted(() => {
    index.bus.on(editorId, {
      name: index.CHANGE_CATALOG_VISIBLE,
      callback: (v) => {
        if (v === void 0) {
          catalogShow.value = !catalogShow.value;
        } else {
          catalogShow.value = v;
        }
      }
    });
  });
  const catalogVisible = vue.computed(() => {
    return !props.toolbarsExclude.includes("catalog") && props.toolbars.includes("catalog") && catalogShow.value;
  });
  return catalogVisible;
};
const useExpose$1 = (props, ctx, catalogVisible, setting, updateSetting, codeRef) => {
  const { editorId } = props;
  vue.watch(
    () => setting.pageFullscreen,
    (newVal) => {
      index.bus.emit(editorId, index.PAGE_FULL_SCREEN_CHANGED, newVal);
    }
  );
  vue.watch(
    () => setting.fullscreen,
    (newVal) => {
      index.bus.emit(editorId, index.FULL_SCREEN_CHANGED, newVal);
    }
  );
  vue.watch(
    () => setting.preview,
    (newVal) => {
      index.bus.emit(editorId, index.PREVIEW_CHANGED, newVal);
    }
  );
  vue.watch(
    () => setting.previewOnly,
    (newVal) => {
      index.bus.emit(editorId, index.PREVIEW_ONLY_CHANGED, newVal);
    }
  );
  vue.watch(
    () => setting.htmlPreview,
    (newVal) => {
      index.bus.emit(editorId, index.HTML_PREVIEW_CHANGED, newVal);
    }
  );
  vue.watch(catalogVisible, (newVal) => {
    index.bus.emit(editorId, index.CATALOG_VISIBLE_CHANGED, newVal);
  });
  const exposeParam = {
    on(eventName, callBack) {
      switch (eventName) {
        case "pageFullscreen": {
          index.bus.on(editorId, {
            name: index.PAGE_FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "fullscreen": {
          index.bus.on(editorId, {
            name: index.FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "preview": {
          index.bus.on(editorId, {
            name: index.PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "previewOnly": {
          index.bus.on(editorId, {
            name: index.PREVIEW_ONLY_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "htmlPreview": {
          index.bus.on(editorId, {
            name: index.HTML_PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "catalog": {
          index.bus.on(editorId, {
            name: index.CATALOG_VISIBLE_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(status) {
      updateSetting("pageFullscreen", status);
    },
    toggleFullscreen(status) {
      index.bus.emit(editorId, index.CHANGE_FULL_SCREEN, status);
    },
    togglePreview(status) {
      updateSetting("preview", status);
    },
    togglePreviewOnly(status) {
      updateSetting("previewOnly", status);
    },
    toggleHtmlPreview(status) {
      updateSetting("htmlPreview", status);
    },
    toggleCatalog(status) {
      index.bus.emit(editorId, index.CHANGE_CATALOG_VISIBLE, status);
    },
    triggerSave() {
      index.bus.emit(editorId, index.ON_SAVE);
    },
    insert(generate) {
      index.bus.emit(editorId, index.REPLACE, "universal", { generate });
    },
    focus(options) {
      var _a;
      (_a = codeRef.value) == null ? void 0 : _a.focus(options);
    },
    rerender() {
      index.bus.emit(editorId, index.RERENDER);
    },
    getSelectedText() {
      var _a;
      return (_a = codeRef.value) == null ? void 0 : _a.getSelectedText();
    },
    resetHistory() {
      var _a;
      (_a = codeRef.value) == null ? void 0 : _a.resetHistory();
    },
    domEventHandlers(handlers) {
      index.bus.emit(editorId, index.EVENT_LISTENER, handlers);
    },
    execCommand(direct) {
      index.bus.emit(editorId, index.REPLACE, direct);
    }
  };
  ctx.expose(exposeParam);
};
const mdHeadingId = (text) => text;
const mdPreviewProps = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: () => index.getNextId("md-editor-v3_")
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: false
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: mdHeadingId
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (html) => html
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: false
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: false
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: true
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: false
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (h) => Promise.resolve(h)
  }
};
const editorProps = {
  ...mdPreviewProps,
  /**
   * input回调事件
   */
  onChange: {
    type: Function
  },
  /**
   * input回调事件
   */
  onSave: {
    type: Function
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: false
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: true
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: false
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: config.allToolbar
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: false
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object]
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: config.allFooter
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: true
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object]
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: false
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWitdh: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  onInputBoxWitdhChange: {
    type: Function
  },
  /**
   * 替换粘贴的图片链接
   *
   * @param t 图片链接
   * @returns
   */
  transformImgUrl: {
    type: Function,
    default: (t) => t
  }
};
const mdPreviewEmits = ["onHtmlChanged", "onGetCatalog"];
const editorEmits = [
  ...mdPreviewEmits,
  "onChange",
  "onSave",
  "onUploadImg",
  "onError",
  "update:modelValue",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "onInputBoxWitdhChange"
];
const useExpose = (props, ctx) => {
  const { editorId } = props;
  const exposeParam = {
    rerender() {
      index.bus.emit(editorId, index.RERENDER);
    }
  };
  ctx.expose(exposeParam);
};
const MdPreview = /* @__PURE__ */ vue.defineComponent({
  name: "MdPreview",
  props: mdPreviewProps,
  emits: mdPreviewEmits,
  setup(props, ctx) {
    const {
      editorId,
      noKatex,
      noMermaid,
      noHighlight
    } = props;
    useProvidePreview(props);
    useExpansionPreview(props);
    useExpose(props, ctx);
    vue.onBeforeUnmount(() => {
      index.bus.clear(editorId);
    });
    return () => {
      return vue.createVNode("div", {
        "id": editorId,
        "class": [config.prefix, props.class, props.theme === "dark" && `${config.prefix}-dark`, `${config.prefix}-previewOnly`],
        "style": props.style
      }, [vue.createVNode(ContentPreview, {
        "modelValue": props.modelValue,
        "onHtmlChanged": (html) => {
          if (props.onHtmlChanged) {
            props.onHtmlChanged(html);
          } else {
            ctx.emit("onHtmlChanged", html);
          }
        },
        "onGetCatalog": (list) => {
          if (props.onGetCatalog) {
            props.onGetCatalog(list);
          } else {
            ctx.emit("onGetCatalog", list);
          }
        },
        "mdHeadingId": props.mdHeadingId,
        "noMermaid": noMermaid,
        "sanitize": props.sanitize,
        "noKatex": noKatex,
        "formatCopiedText": props.formatCopiedText,
        "noHighlight": noHighlight,
        "noImgZoomIn": props.noImgZoomIn,
        "previewOnly": true,
        "sanitizeMermaid": props.sanitizeMermaid
      }, null)]);
    };
  }
});
MdPreview.install = (app) => {
  app.component(MdPreview.name, MdPreview);
  return app;
};
exports.ContentPreview = ContentPreview;
exports.MdPreview = MdPreview;
exports.contentProps = contentProps;
exports.editorEmits = editorEmits;
exports.editorProps = editorProps;
exports.useCatalog = useCatalog;
exports.useConfig = useConfig;
exports.useErrorCatcher = useErrorCatcher;
exports.useExpansion = useExpansion;
exports.useExpose = useExpose$1;
exports.useOnSave = useOnSave;
exports.useProvide = useProvide;
